##题目

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

**示例 1：**
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

**示例 2：**
输入：nums = [1]
输出：1

**示例 3：**
输入：nums = [5,4,-1,7,8]
输出：23

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/maximum-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


**首先分析思路**

最容易想到的方法便是从每一项开始，向后寻找包含该项的最大子数组的和。这是暴力解法，时间复杂度为$O(n^2)$,显然不能满足时间复杂度的需求。

再进一步思考，本题只要求返回最大值而不是该数组，因此有动态规划问题的特征，那么尝试分析动态规划的子问题和状态转移方程。

将第一个思路进行逆向思维：能不能视作每一项之前的所有项中的最大子数组的和。这样，子问题就可以建模为包含$nums(i)$时的子数组最大和与包含$nums(i+1）$后的子数组最大值两者的大小比较。

因此，可以有如下算法：

1. 建立一个长度与$nums$相同的数组$dp$,用作备忘录。
2. 从第一项开始，比较$dp(i-1)$和$dp(i-1)+nums(i)$的大小并存入$dp(i)$位置
3. 最后求出$dp$数组的最大值，即为所求。


~~~python
from typing import List
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        size = len(nums)
        if size == 0:
            return 0
        dp = [0 for _ in range(size)]

        dp[0] = nums[0]
        for i in range(1, size):
            if dp[i - 1] >= 0:
                dp[i] = dp[i - 1] + nums[i]
            else:
                dp[i] = nums[i]
        return max(dp)
~~~

此题是经典动态规划题，考察了如何分析一个问题的子问题，以及如何拆分条件得到状态转移方程。值得关注和记忆。