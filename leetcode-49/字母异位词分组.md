##题目

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

 

**示例 1:**
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: \[["bat"],["nat","tan"],["ate","eat","tea"]]

**示例 2:**
输入: strs = [""]
输出: \[[""]]

**示例 3:**
输入: strs = ["a"]
输出: \[["a"]]

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/group-anagrams
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


先考虑一下解题的思路。首先能想到的一定是暴力求解。对于一个item，构造函数判断之后的元素是否和item由相同的元素构成，并且元素的数量必须一致。而且还面临着极其复杂的去重操作。

显然，暴力的方法将会浪费大量的开发精力和运行效率，并不值得提倡，于是便有了如下的方法：

~~~python
class Solution(object):
    def groupAnagrams(self, strs):
        """
        :type strs: List[str]
        :rtype: List[List[str]]
        """
        dic = {}  # 用字典进行存取
        for s in strs:  # 对每个字符串进行遍历
            keys = "".join(sorted(s))  # 对字符串进行正序排列
            if keys not in dic:  # 只有一个的情况
                dic[keys] = [s]  # 要记得带中括号，否则下面不能使用append()，而且最后的输出也需要。
            else:  # 多个的情况
                dic[keys].append(s)
        
        return list(dic.values())  # 只输出字典的值，并且转成列表格式。
~~~

此题采用的便是简单的字典序排列法。首先需要直到字符串正序排列的意义：由于字母是有顺序的，因此字符串只要组成元素相同，其正序排列的结果一定是相同的。

这样就有了可以比较的标准。遍历strs的每一个元素，将其元素的正序排列字符串作为$key$值，下面只要strs后续的元素的正序排列字符串和$key$值相同就作为$value$添加到对应的$key$下。

这样不仅能仅仅通过一次遍历就得到了结果，而且因为字典的$key$是不会重复的，因此免去了去重的操作。可谓是一箭双雕。

私以为，编程应当以解决问题为第一要务，因此复杂的暴力搜索并不值得继续研究，如果有更好的方式，就应该大胆地用。
