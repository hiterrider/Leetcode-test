#题目
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1: 输入: "abcabcbb" 输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。


分析：采用**滑动窗口**的算法。建立一个动态的窗口（实际就是无重复的子串）遍历主串，每遍历一个新字符则在窗口中查找是否包含该字符，无则窗口增大，继续遍历。若已存在该字符则记录窗口长度，将窗口滑动至重复字符后，继续向下遍历，最后返回窗口的最大长度。

滑动窗口的要点在于，start指针应该在什么时候移动，移动到哪里。经过分析可以得到如下：
1. start指针受到遍历指针i的作用，i遍历元素时，每一次遇到元素都会查找字典，当元素无重复，则将该元素和index作为键值对存入字典；遇到重复时，i指针停止，不再移动
2. 此时，start指针应该移动，移动直到i指针再度合法移动为止。因此，可以知道，start指针应该**移动到重复元素尚未更新位置时的index后一位**。
3. 当start指针移动结束时，此时的滑动窗口内部再无重复元素，i指针继续移动，同时将字典中的元素位置进行更新，以备下一次start指针移动。
   
python代码：
~~~python
def lengthOfLongestSubstring(s):
    """
    :type s: str
    :rtype: int
    """
    # 存储历史循环中最长的子串长度
    max_len = 0
    # 判断传入的字符串是否为空
    if s is None or len(s) == 0:
        return max_len
    # 定义一个字典，存储不重复的字符和字符所在的下标,字典的键（key）是字符，字典的值（value）是字符最后出现的index
    str_dict = {}
    # 存储每次循环中最长的子串长度
    one_max = 0
    # 记录最近重复字符所在的位置+1，or 设定头指针
    start = 0
    for i in range(len(s)):
        # 对于第一个字符，判断当前字符是否在字典中 & 当前字符的下标是否大于等于最近重复字符的所在位置
        # 如果字符在字典中，则说明重复了；如果字符下标索引的值str_dict[s[i]]>=start,说明在头指针右侧
        if s[i] in str_dict and str_dict[s[i]] >= start:
            # 记录当前字符的值+1
            start = str_dict[s[i]] + 1

        #如果字符不在字典中则进行如下：
        # 在此次循环中，最大的不重复子串的长度
        one_max = i - start + 1
        # 把当前位置覆盖字典中的位置，记录该字符以及所在的index
        str_dict[s[i]] = i
        # 比较此次循环的最大不重复子串长度和历史循环最大不重复子串长度
        max_len = max(max_len, one_max)
    return max_len,str_dict

print(lengthOfLongestSubstring("pwwwkew"))
~~~